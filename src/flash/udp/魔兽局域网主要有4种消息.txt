魔兽局域网主要有4种消息 
第一种、搜索游戏： 
F7 2F 10 00 50 58 33 57 15 00 00 00 00 00 00 00 ?PX3W 
这个格式比较简单。 
F7 2F 10 00 是格式头部，消息含义的标志。 
50 58 33 57 是PX3W几个字，就是冰封王座的逆序。 
15 00 00 00 是版本号，0x15=21，即是1.21版的冰封王座在搜索游戏。 
00 00 00 00 是某个魔兽的标志，看似无意义，实际很重要。后面会说明。 

魔兽在多种情况下都会发布此消息，例如刚进入局域网，从游戏中退出，从创建的游戏中退出等等。 

第二种、结束游戏： 
F7 33 08 00 00 00 00 00 
F7 33 08 00为消息内容标志，00 00 00 00同第一种消息，后面说明。 
魔兽在收到此消息后会从游戏列表中删除对应IP的游戏。 
魔兽在取消游戏或者开始游戏时会发送此消息。 

第三种、LANTag 
这个是魔兽中传输次数最多的消息。短小但是作用多。 
F7 32 10 00 00 00 00 00 01 00 00 00 00 00 00 00 ? 
F7 32 10 00 消息标志，不多说了。 
00 00 00 00 神秘标志。 
01 00 00 00 忘了，貌似是固定值 
02 00 00 00 空余位置数＋1 

那个特殊的标志是什么呢？那个就是魔兽创建游戏的次数。 
它表示了当前是第几次游戏。关闭游戏后重置为0。看似这个是没什么用的标志，但是魔兽程序对收到的消息中这个值不对（和当前系统游戏次数不同）的消息都是无视，例如创建了8次游戏的魔兽服务器（主机），对F7 2F 10 00 50 58 33 57 15 00 00 00 01 00 00 00是没有反映的，F7 2F 10 00 50 58 33 57 15 00 00 00 08 00 00 00才能正常的返回游戏信息。但是作为一个特例，所有主机对00都有响应。但是其中还稍有不同。我们先把这个标志成为tagcount。 

这个LANtag有很多用处。处于等待状态的魔兽收到lantag后会发送一个tagcount和lantag中相同的搜索游戏消息（第一种消息）。已经搜索到对应IP创建的游戏的魔兽会根据lantag改变游戏列表中空余位置的显示。同时tagcount=00的特殊性就体现在这里，搜索到某IP创建的游戏的魔兽对00会返回搜索游戏消息，而不管是从哪个ip发来的，而对从该IP发送过来的tagcount不等于0的lantag无返回消息。 

第四种、游戏信息： 




F7 30 8B 00消息标志，略过。 
58 33 57 15 冰封王座标志，略过。 
15 00 00 00 版本号。 
01 00 00 00 tagcount，请参考上文。 
39 0A E5 01 未知，每次消息都不同 
00 01 03 49 07 01 01 55 01 D1 55 01 0D 65 C3 9B：未知，包含例如是否开图，是否开启裁判等信息。 
E5 BD 93 E5 9C B0 E5 B1 80 E5 9F 9F E7 BD 91 E5 86 85 E7 9A 84 E6 B8 B8 E6 88 8F 20 28 46 6C 00：UTF-8的局域网游戏名称“当地局域网内的游戏 (Fl”。 
4D EB 61 71 73 5D 69 65 73 A1 75 5D 
29 33 29 55 65 75 73 65 6F 61 73 53 75 63 61 6F 
65 2F 77 33 79 B1 01 47 6D 79 69 6F 67 1B 53 6F 
6F 77 01 01 
一段简单加密的信息，地图和创建者信息。加密规则如下。 
从"(Fl/0"后开始往后第10个字节开始，每8个为一个加密组，例如： 
D1 55 01 0D 65 C3 9B 4D为一个加密组，D1为密钥。 
EB 61 71 73 5D 69 65 73为一个加密组，EB为密钥。 
其实是一段简单的奇偶校验加密。 
0xEB=11101011。将二进制字符串逆序取反为00101000，所以，正确字符串为： 
EB-0 61-0 71-1 73-0 5D-1 69-0 65-0 73-0 
其中密钥位舍去，得61 70 73 5C 69 65 73即为aps/ies 
如此解密此部分数据为： 
Maps/iest/(2)EchoIsles.w3x/0FlyingSnow/0/0 
/0为结束符，即二进制00。 
最后以一个00最结束。 
02 00 00 00：游戏总共允许玩家。 
01 00 00 00：未知，似乎是电脑数。 
01 00 00 00：未知，似乎是玩家数。 
01 00 00 00：剩余空位。 
08 00 00 00：未知。似乎是定值。 
E0 17=0x17E0=6112，游戏端口。 
至此分析完毕。 
游戏数据流程是，魔兽发送搜索信息->接受游戏信息->根据Lantag调整空闲人数。 
魔兽启动局域网时会发送一个搜索信息广播（仅当前子网），仅广播一次。 
当新游戏主机加入时，该游戏主机广播一个Lantag，魔兽收到Lantag后向该主机发送搜索消息。游戏主机在创建完游戏等待加入时每隔一段时间广播一个Lantag。游戏主机的空闲位置有任何变化时广播Lantag。 
取消或开始游戏后发送结束消息

bcc(block check character)校验的
因为replay只记录动作

主要UDP包：
收索包:
内容：F7 2F 10 00 50 58 33 57 15 00 00 00 00 00 00 00
功能：向主机提出收索信息。问别人“你建什么主机？”
在打开魔兽进入局域网的时候，会向当前网段（255.255.255.255）广播这个包。只要条件符合，收到这个包的主机都会返回一个地图信息给他（他：这个收索包的IP端口）
主机包：
内容：F7 32 10 00 00 00 00 00 01 00 00 00 00 00 00 00
功能：告诉别人：“我建主机了，要不要看看。”
建立主机的时候开始，向当前网段广播这个包，每5秒钟一次。收到这包的客户机会发送搜索包。
地图包：
内容：  
F7 30 8C 00 50 58 33 57  14 00 00 00 01 00 00 00  
39 69 C2 00 E5 BD 93 E5  9C B0 E5 B1 80 E5 9F 9F  
E7 BD 91 E5 86 85 E7 9A  84 E6 B8 B8 E6 88 8F 20   
28 76 73 00 00 01 03 49  07 01 01 77 01 B9 79 01   
99 D5 B9 31 4D CB 61 71  73 5D 45 6F 77 19 6F 6D   
6F 61 65 5D 45 2B 6F 75  41 21 41 6D 6D 2B 73 75  
61 73 73 21 77 B1 37 2F  37 31 63 2F 77 23 33 79   
01 77 73 01 01 00 0A 00  00 00 01 00 00 00 01 00 
00 00 0A 00 00 00 1B 00  00 00 E0 17              
功能：“这就是我所建的图，你好好看。”
主机收到搜索包之后就把这个包返回给他，包括所有有用信息。

魔兽的工作流程
魔兽进入局域网的时候会广播一个搜索包，只发送一次。只发送当前网段（255.255.255.255），所以我们的魔兽只能看到本寝室，或者少数几个寝室的几个主机。

建立了了主机的魔兽收到之后就会发送一个包给他，这个包就是地图信息，包括地图信息，主机名，加入了多少人，剩下多少位置，还有一个重要的数据就是游戏的端口。一般魔兽的端口是6112.

建立主机的魔兽会向本地发送一个包，“我建立主机了”

搜到这条消息的魔兽会发送一个搜索包给主机。

主机就发送 地图信息。

收到之后就解析地图，这时候大家就看到了有人建主了                   点击加入· ~  建立tcp连接 一直到推出主机的游戏

ps： 一场游戏下来，和主机发送的包 大概25MB（半小时） 主机收发的包就是 9*25 MB/30 min ;//按照dota计算 一个主+9个客户端的10人游戏。 这样粗略的估计主机的网速要求就是 9*25*1024/30*60=128>100 kb/s 加上一点点别的程序所要的通讯包。要想不卡，主机的网速需要保证这个数吧。



关键技术

1，监听主机（建立了魔兽地图的机器）的地图信息。
      
      有两种方法能获得地图信息，一种是抓包，把所有的和6112端口有关的包都抓过来分析。（个人觉得这样电脑的负担太大了）。现在的多数搜索器都是这样实现的。
      但是Java要实现抓包不是很容易。c++能实现这个功能，可以考虑用c++编译一个dll。Java调用。或者用开源项目。搜搜就能找到。
      
      我用的方法是建立一个线程。每5秒钟发送一个包收索本机是否建立主机。如果自己建立了主机，则会返回一个地图信息包。收到之后告诉其他ip“我建主了”；
      这样客户端就不需要一直发送搜索包了。
      找到了主机，一切都好办了。
 2，告诉别人我建主机了
      如何告诉别人我建立了主机。很简单，建立了主机的魔兽会每5秒钟发送一个包给当前网段，告诉别人我建主机了。
      我们只要把这个包发送到其他ip的6112端口就ok了。就是告诉别人“我建主了”，收到的人就会发送一个包：“看看什么图”，然后主机就会回复一个包，没错这就    是地图信息！
      
 3，解析地图
      不解析地图不会对游戏产生任何影响。因为魔兽接受地图包，自己解析，它很明白这图是什么。但是解析地图，你可以知道主机建立的这个地图是什么，主机叫什么    名字，有几个人加入，有几个电脑。还有几个空位置。主机是什么版本。这些很有用的信息在软件上显示出来时很有用的！
      关于UDP包的解说有好多的文章。大家可以去google上搜索一下，关键字 魔兽 UDP 
      我这里就几点补充。

这个是网上的：

02 00 00 00：游戏总共允许玩家。 
01 00 00 00：未知，似乎是电脑数。 
01 00 00 00：未知，似乎是玩家数。 
01 00 00 00：剩余空位。 
08 00 00 00：未知。似乎是定值。

E0 17=0x17E0=6112，游戏端口。

02 00 00 00：游戏总共允许玩家。 
01 00 00 00：未知，这似乎是定值。 
01 00 00 00：已知，这就是是玩家数。 
01 00 00 00：已知，除电脑外的所有空位。 
08 00 00 00：未知。不断变化着……。

E0 17=0x17E0=6112，游戏端口。

 

all = map[map.length - 22];  
unknown = map[map.length - 18];  
people = map[map.length - 14];  
esidescp= map[map.length - 10];// 这个数是这样计算的：除电脑外的所有位置，包括已经有人的位置，例如总数是10个，加了3个电脑，则这个数就是7，不关那7个位置是否有无人。  
 

// 这个数是这样计算的：除电脑外的所有位置，包括已经有人的位置，例如总数是10个，加了3个电脑，则这个数就是7，不关那7个位置是否有无人。

这里把地图的解析代码贴出来。

 

view plaincopy to clipboardprint?
/** 
 * 魔兽的主机节点（游戏中的“建主”了，也就是建立了什么地图） 
 * 解析主机信息 
 * 生成一个主机节点，包括地图信息,版本，人数，等等 
 *参数：byte[] 地图信息包,InetAddress 包的ip地址，int 延时 
 */  
package xinyu126.common;  
import java.io.UnsupportedEncodingException;  
import java.net.InetAddress;  
import java.util.Arrays;  
import java.util.Vector;  
/** 
 * @author xinyu126 
 *  
 */  
public class WarNode {  
    String serverName;  
    String serverInfo;  
    String mapStr;  
    int all;  
    int besidescp;  
    int people;  
    int unknow;  
    int version;  
    int timeDelay;  
    public InetAddress IP = null;  
    public boolean checked = true;  
    public WarNode(byte[] map, InetAddress IP, int delay) {  
        int i = 0;  
        if (map[0] != (byte) 0xf7 || map[1] != (byte) 0x30) {  
            // 这个不是地图信息！  
            return;  
        }  
        this.IP = IP;  
        this.timeDelay = delay;  
        // 第八个是版本，1.20(20) 1.21(21)什么的  
        version = map[8];  
        // 从第二十个开始  
        // 游戏信息，大部分是：“当地局域网内游戏（X……”  
        byte[] t = new byte[32];  
        for (i = 0; i < 32; i++) {  
            t[i] = map[i + 20];  
        }  
        try {  
            serverInfo = new String(t, "UTF-8");  
        } catch (UnsupportedEncodingException e) {  
            e.printStackTrace();  
        }  
          
        // 现在开始解析地图路径和主机的名字  
        i = 69;  
        byte[] mapStr = new byte[64];  
        t = new byte[32];  
        int v = 0;  
        int n = 0;  
        boolean flag = true;  
        do {  
            String mm = "00000000" + Integer.toBinaryString(~map[i]);  
            // System.out.println(mm);  
            for (int j = 1; j < 8; j++) {  
                int c = map[i + j];  
                if (c == 0) {  
                    // 如果遇到0x00表示已经结束了  
                    break;  
                }  
                int k = '1' == mm.charAt(mm.length() - j - 1) ? 1 : 0;  
                // System.out.println(k);  
                  
                if (c == 1) {  
                    // 当遇到第一个 0x01的时候表示地图路径完事了，开始解析主机的名字  
                    flag = false;  
                }  
                if (flag) {  
                    // 加到地图上  
                    mapStr[v] = (byte) (c - k);  
                    v++;  
                } else {  
                    // 加到名字上  
                    // 注意这里：如果名字不够长，这8个字节中不能放下01 01 00这三个字节，则会在后面添上“争霸”这个两个中文“d5  
                    // f9 b1 d5”，然后另起8个字节，放下01 01 00.这个时候要注意去掉这个“争霸”。防止乱码  
                    //   
                    // TODO 暂时这样处理。知道还有很多问题  
                    if (c != (byte) 0xd5 && c != (byte) 0xf9 && c != (byte) 0xb1) {  
                        t[n] = (byte) (c - k);  
                        n++;  
                    }  
                }                 
            }  
            i += 8;  
        } while (map[i] != 1 && i < map.length - 25);  
        this.mapStr = "M" + new String(Arrays.copyOf(mapStr, v));  
        serverName = new String(Arrays.copyOf(t, n));  
        all = map[map.length - 22];  
        unknow = map[map.length - 18];  
        people = map[map.length - 14];//  
        besidescp = map[map.length - 10];// 这个数是这样计算的：除电脑外的所有位置，包括已经有人的位置，例如总数是10个，加了3个电脑，则这个数就是7，不关那7个位置是否有无人。  
        // System.out.println(serverInfo + "  " + serverName + " " + this.mapStr  
        // + all + " " + computer);  
    }  
    public Vector<String> getInfo() {  
        Vector<String> vv=new Vector<String>();  
        vv.add("1." + version);  
        vv.add(IP.getHostAddress());  
        vv.add(serverName);  
        vv.add(serverInfo);  
        vv.add(mapStr);  
        vv.add("" + (all - besidescp + people) + "|" + all);  
        vv.add(String.valueOf(all - besidescp));  
        vv.add("" + timeDelay);  
        return vv;  
    }  
    public void setTimeDelay(int delay) {  
        this.timeDelay = delay;  
    }  
}  