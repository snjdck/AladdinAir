"use strict";

const Socket = require("net").Socket;

Socket.prototype.readForever = function(handler){
	var buffer = new Buffer(0);
	var begin = 0;
	this.on("data", chunk => {
		const end = buffer.length + chunk.length;
		buffer = Buffer.concat([buffer, chunk], end);
		for(;;){
			if(end - begin < 2)
				break;
			const packetLen = buffer.readUInt16BE(begin);
			if(packetLen < 2){
				this.destroy();
				return;
			}
			if(end - begin < packetLen)
				break;
			handler.call(this, buffer.slice(begin, begin+packetLen));
			begin += packetLen;
		}
		if(begin > 0){
			buffer = buffer.slice(begin);
			begin = 0;
		}
	});
};

Socket.prototype.listenCloseEvent = function(timeout, handler){
	const onClose = () => {
		this.removeAllListeners();
		if(handler != null)
			handler(this);
	};
	this.on("close",  onClose);
	this.on("error",  onClose);
	this.on("timeout",onClose);
	this.setTimeout(timeout);
};

const EventEmitter = require('events');

class PacketSocket extends EventEmitter
{
	constructor(socket){
		this.socket = socket;
	}

	readForever(){
		const {socket} = this;
		var buffer = new Buffer(0);
		var begin = 0;
		socket.on("data", chunk => {
			const end = buffer.length + chunk.length;
			buffer = Buffer.concat([buffer, chunk], end);
			for(;;){
				if(end - begin < 2)
					break;
				const packetLen = buffer.readUInt16BE(begin);
				if(packetLen < 2){
					socket.destroy();
					return;
				}
				if(end - begin < packetLen)
					break;
				const hasBufferListeners = this.listenerCount("buffer") > 0;
				const hasPacketListeners = this.listenerCount("packet") > 0;
				if(hasBufferListeners || hasPacketListeners){
					const data = buffer.slice(begin, begin+packetLen);
					if(hasBufferListeners)this.emit("buffer", data);
					if(hasPacketListeners)this.emit("packet", Packet.parse(data));
				}
				begin += packetLen;
			}
			if(begin > 0){
				buffer = buffer.slice(begin);
				begin = 0;
			}
		});
	}

	send(packet){
		const {socket} = this;
		socket.write(packet);
	}

	request(packet){
		const reqID = 0;
		packet.reqID = reqID;
		this.send(packet);
		return new Promise((resolve, reject) => {
			const timerID = setTimeout(() => {
				this.removeListener("packet", handler);
				reject(new Error("request timeout!"));
			}, 5000);//5 seconds
			function handler(packet){
				if(packet.reqID == reqID){
					this.removeListener("packet", handler);
					clearTimeout(timerID);
					resolve(packet.msgData);
				}
			}
			this.on("packet", handler);
		});
	}
}